<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Shooter Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #hud {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff88;
      font-family: monospace, monospace;
      font-size: 1.5em;
      text-shadow: 0 0 8px #000, 0 0 2px #00ff88;
      z-index: 10;
      pointer-events: none;
      user-select: none;
    }
    #killsHud {
      position: absolute;
      top: 18px;
      left: 24px;
      display: flex;
      align-items: center;
      z-index: 11;
      font-family: monospace, monospace;
      font-size: 1.3em;
      pointer-events: none;
      user-select: none;
    }
    #killsHud .red-square {
      width: 28px;
      height: 28px;
      background: #ff2222;
      border-radius: 6px;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 0 8px #a00;
    }
    #killsHud .kill-count {
      color: #fff;
      font-weight: bold;
      text-shadow: 0 0 6px #a00;
      font-size: 1.1em;
    }
    #moneyHud {
      position: absolute;
      top: 54px;
      left: 24px;
      display: flex;
      align-items: center;
      z-index: 11;
      font-family: monospace, monospace;
      font-size: 1.3em;
      pointer-events: none;
      user-select: none;
    }
    #moneyHud .money-label {
      color: #ffe066;
      font-weight: bold;
      margin-right: 8px;
      font-size: 1.2em;
      text-shadow: 0 0 6px #a80;
    }
    #moneyHud .money-count {
      color: #fffbe0;
      font-weight: bold;
      text-shadow: 0 0 6px #a80;
      font-size: 1.1em;
    }
    .animated-text {
      animation: pop 0.3s;
    }
    @keyframes pop {
      0% { transform: scale(1.3); color: #fffbe0; }
      80% { transform: scale(1.1); }
      100% { transform: scale(1); color: inherit; }
    }

    /* Wave HUD: gentle fade-in */
    .wave-animate {
      animation: waveFade 0.7s;
    }
    @keyframes waveFade {
      0% { opacity: 0; letter-spacing: 0.2em; }
      60% { opacity: 1; letter-spacing: 0.05em; }
      100% { opacity: 1; letter-spacing: normal; }
    }

    /* Kills: subtle scale */
    .kills-animate {
      animation: killsPop 0.35s;
    }
    @keyframes killsPop {
      0% { transform: scale(1.3);}
      80% { transform: scale(1.05);}
      100% { transform: scale(1);}
    }

    /* Slide out kills and money elegantly */
    .slide-left {
      animation: slideLeft 0.7s forwards;
    }
    @keyframes slideLeft {
      0% { opacity: 1; transform: translateX(0);}
      100% { opacity: 0; transform: translateX(-120px);}
    }

    /* Money: gentle color flash */
    .money-animate {
      animation: moneyFlash 0.4s;
    }
    @keyframes moneyFlash {
      0% { color: #ffe066; }
      60% { color: #fffbe0; }
      100% { color: inherit; }
    }

    /* Upgrade Tab: smooth slide-in and glow for buttons */
    .upgrade-title-animate {
      animation: upgradeTitleIn 0.7s;
    }
    @keyframes upgradeTitleIn {
      0% { opacity: 0; transform: translateY(-30px) scale(1.2);}
      100% { opacity: 1; transform: translateY(0) scale(1);}
    }
    .upgrade-btn-animate {
      animation: upgradeBtnGlow 0.7s;
    }
    @keyframes upgradeBtnGlow {
      0% { box-shadow: 0 0 0 #00ff88; opacity: 0; transform: scale(0.9);}
      60% { box-shadow: 0 0 16px #00ff88; opacity: 1; transform: scale(1.05);}
      100% { box-shadow: 0 0 0 #00ff88; opacity: 1; transform: scale(1);}
    }
    .upgrade-msg-animate {
      animation: upgradeMsgFade 0.5s;
    }
    @keyframes upgradeMsgFade {
      0% { opacity: 0; transform: translateY(10px);}
      100% { opacity: 1; transform: translateY(0);}
    }

    /* Upgrade summary in upgrade tab */
    #upgradeSummary {
      color: #fffbe0;
      font-family: monospace;
      font-size: 1.2em;
      margin-bottom: 18px;
      text-align: center;
      letter-spacing: 0.03em;
    }

    /* Timer bar: small thin line */
    #upgradeTimerBar {
      width: 100%;
      height: 4px !important;
      background: #222;
      border-radius: 2px;
      margin-bottom: 16px;
      overflow: hidden;
      position: relative;
    }
    #upgradeTimerFill {
      height: 100%;
      width: 100%;
      background: #00ff88;
      transition: width 0.1s;
    }
    #upgradeTimerText {
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff88;
      font-family: monospace;
      font-size: 1em;
      letter-spacing: 0.04em;
    }

    /* Pause overlay */
    #pauseOverlay {
      display: none;
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.7);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }
    #pauseOverlay .pause-content {
      color: #00ff88;
      font-family: monospace;
      font-size: 2.2em;
      text-align: center;
      text-shadow: 0 0 12px #000, 0 0 4px #00ff88;
      background: #181818cc;
      border-radius: 18px;
      padding: 48px 64px;
      box-shadow: 0 0 32px #000a;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="killsHud"><div class="red-square"></div><span class="kill-count">0</span></div>
  <div id="moneyHud"><span class="money-label">$</span><span class="money-count">0</span></div>
  <div id="upgradeOverlay" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0); z-index:100; transition:background 0.7s;">
    <div id="upgradePanel" style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:#181818ee; border-radius:18px; padding:36px 32px; box-shadow:0 0 32px #000a; display:flex; flex-direction:column; align-items:center; opacity:0; transition:opacity 0.5s;">
      <h2 style="color:#00ff88; margin-bottom:18px; font-family:monospace;">Choose an Upgrade</h2>
      <div id="upgradeTabs" style="display:flex; gap:22px; margin-bottom:10px;"></div>
      <div id="upgradeMsg" style="color:#ff8888; margin-top:10px; min-height:24px; font-family:monospace;"></div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
  <script>
    let gamePaused = true; // Only declare this ONCE, at the top

    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Spotlight
    const spotlight = new THREE.SpotLight(0xffffff, 1.5);
    spotlight.position.set(0, 15, 0);
    spotlight.angle = Math.PI / 4;
    spotlight.castShadow = true;
    scene.add(spotlight);

    // Floor
    const gridSize = 20;
    const tileSize = 1;
    const groundGroup = new THREE.Group();
    const tileMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Neutral dark gray ground
    for (let x = -gridSize / 2; x < gridSize / 2; x++) {
      for (let z = -gridSize / 2; z < gridSize / 2; z++) {
        const tileGeometry = new THREE.PlaneGeometry(tileSize, tileSize);
        const tile = new THREE.Mesh(tileGeometry, tileMaterial);
        tile.rotation.x = -Math.PI / 2;
        tile.position.set(x + 0.5, 0, z + 0.5);
        tile.receiveShadow = true;
        groundGroup.add(tile);
      }
    }
    scene.add(groundGroup);

    // Player (Diamond Shape)
    const playerGeometry = new THREE.OctahedronGeometry(0.5); // Diamond-like shape
    const playerMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ff00, // Green color
      emissive: 0x00ff00, // Green glow
      emissiveIntensity: 0.5, // Glow intensity
    });
    const player = new THREE.Mesh(playerGeometry, playerMaterial);

    // Scale the crystal to make it longer along the Y-axis
    player.scale.set(1, 1.5, 1); // Stretch vertically (Y-axis) without affecting width (X, Z)

    // Move the crystal just a bit higher
    player.position.set(0, 0.72, 0); // Y-position to 0.72
    player.castShadow = false; // Disable shadow casting for the crystal
    scene.add(player);

    // Add Light Emission from the Crystal
    const crystalLight = new THREE.PointLight(0x00ff00, 1, 10); // Green light with intensity and range
    crystalLight.position.set(0, 0.72, 0); // Light follows
    crystalLight.castShadow = true; // Enable shadows from the light
    scene.add(crystalLight);

    // Floating Animation Variables
    let floatTime = 0;

    // Add these variables near your other animation variables:
    let targetLeanX = 0;
    let targetLeanZ = 0;

    // Weapons
    const weapons = ['Pistol', 'Rifle', 'Shotgun'];
    let currentWeapon = 0;

    // Projectiles
    const projectiles = [];
    const projectileSpeed = 0.5;

    // Enemies
    const enemies = [];
    function spawnEnemy() {
      if (!waveInProgress) return;
      // Only spawn if we haven't spawned all for this wave and not over 18 at once
      if (enemies.length >= Math.min(18, enemiesToKill - killedThisWave)) return;

      // Normal size with very slight variation
      const baseColor = 0xff2222; // Red base
      const size = 0.48 + Math.random() * 0.08; // Range: 0.48 - 0.56
      const enemyGeometry = new THREE.BoxGeometry(size, size, size);
      const enemyMaterial = new THREE.MeshStandardMaterial({
        color: baseColor,
        opacity: 1, // Fully visible
        emissive: baseColor,
        emissiveIntensity: 0.5
      });
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

      // Spawn enemies far from the player
      const spawnRange = 20;
      const minDistance = 10;
      let x, z;
      do {
        x = Math.random() * spawnRange - spawnRange / 2;
        z = Math.random() * spawnRange - spawnRange / 2;
      } while (Math.sqrt((x - player.position.x) ** 2 + (z - player.position.z) ** 2) < minDistance);

      enemy.position.set(x, size / 2, z);
      enemies.push(enemy);
      scene.add(enemy);
    }
    setInterval(spawnEnemy, 2000); // Spawn an enemy every 2 seconds

    // Handle Weapon Switching
    window.addEventListener('keydown', (event) => {
      if (event.key === '1') currentWeapon = 0; // Pistol
      if (event.key === '2') currentWeapon = 1; // Rifle
      if (event.key === '3') currentWeapon = 2; // Shotgun
    });

    // Detection Radius
    const detectionRadius = 5; // Radius within which enemies are detected
    const detectionSphereGeometry = new THREE.SphereGeometry(detectionRadius, 32, 32);
    const detectionSphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      wireframe: true,
      opacity: 0.3,
      transparent: true,
    });
    const detectionSphere = new THREE.Mesh(detectionSphereGeometry, detectionSphereMaterial);
    detectionSphere.position.set(player.position.x, player.position.y, player.position.z);
    detectionSphere.visible = false; // Hide the Detection Sphere
    scene.add(detectionSphere);

    // Update Detection Sphere Position
    function updateDetectionSphere() {
      detectionSphere.scale.set(playerRange / 5, playerRange / 5, playerRange / 5);
      detectionSphere.position.set(player.position.x, player.position.y, player.position.z);
    }

    // Update Crystal Light Position
    function updateCrystalLight() {
      crystalLight.position.set(player.position.x, player.position.y, player.position.z);
    }

    // Automatic Shooting at Enemies Within Radius (with 3-second cooldown)
    let lastShootTime = 0; // Track the last time the player shot
    function autoShootAtEnemies() {
      const currentTime = performance.now(); // Get the current time
      if (currentTime - lastShootTime < shootCooldown) return; // Skip if cooldown is active

      for (const enemy of enemies) {
        const distance = player.position.distanceTo(enemy.position);
        if (distance <= detectionRadius) {
          // Shoot at the enemy
          const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
          const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green bullets
          const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
          projectile.position.set(player.position.x, player.position.y, player.position.z);

          // Calculate direction toward the enemy
          const direction = enemy.position.clone().sub(player.position).normalize();
          projectile.direction = direction;

          projectiles.push(projectile);
          scene.add(projectile);

          createMuzzleFlash(player.position); // Add muzzle flash effect

          lastShootTime = currentTime; // Update the last shoot time
          break; // Only shoot at one enemy per frame
        }
      }
    }

    // Update Projectiles
    function updateProjectiles() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.position.add(projectile.direction.clone().multiplyScalar(projectileSpeed));

        // Remove projectiles that go out of bounds
        if (
          Math.abs(projectile.position.x) > gridSize / 2 ||
          Math.abs(projectile.position.z) > gridSize / 2
        ) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }

        // Check for collisions with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (projectile.position.distanceTo(enemy.position) < 0.5) {
            // Create explosion at the enemy's position
            createExplosion(enemy.position, 0xff2222);

            // Remove enemy and projectile
            scene.remove(enemy);
            enemies.splice(j, 1);
            scene.remove(projectile);
            projectiles.splice(i, 1);

            killedThisWave++;
            money += moneyGain;
            updateHUD();

            // Check if wave is complete
            if (killedThisWave >= enemiesToKill) {
              waveInProgress = false;
              setTimeout(() => {
                slideOutStatsAndShowUpgrade();
              }, 1000); // 1 second pause before upgrade
            }
            break;
          }
        }
      }
    }

    // Explosion Effect
    function createExplosion(position, baseColor) {
      const explosionGroup = new THREE.Group();
      const bloodFragments = [];
      const splatters = [];

      // Blood fragments (small squares that fall and splatter)
      for (let i = 0; i < 14; i++) {
        const fragSize = 0.08 + Math.random() * 0.06;
        const fragGeometry = new THREE.BoxGeometry(fragSize, fragSize, fragSize);
        const fragMaterial = new THREE.MeshStandardMaterial({
          color: baseColor,
          emissive: baseColor,
          emissiveIntensity: 1,
          transparent: true,
          opacity: 1
        });
        const fragment = new THREE.Mesh(fragGeometry, fragMaterial);
        fragment.position.copy(position);
        fragment.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 1.1, // less horizontal spread
          Math.random() * 1.2 + 0.7,   // less vertical velocity
          (Math.random() - 0.5) * 1.1
        );
        fragment.landed = false;
        explosionGroup.add(fragment);
        bloodFragments.push(fragment);
      }

      // Regular explosion fragments (debris)
      for (let i = 0; i < 18; i++) {
        const color = baseColor;
        const particleGeometry = new THREE.BoxGeometry(
          0.07 + Math.random() * 0.07,
          0.07 + Math.random() * 0.15,
          0.07 + Math.random() * 0.07
        );
        const particleMaterial = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 1,
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3
        );
        particle.rotationSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3
        );
        explosionGroup.add(particle);
      }

      scene.add(explosionGroup);

      let explosionTime = 0;
      function animateExplosion() {
        explosionTime += 0.05;

        // Animate blood fragments
        bloodFragments.forEach(fragment => {
          if (!fragment.landed) {
            fragment.velocity.y -= 0.13;
            fragment.position.add(fragment.velocity.clone().multiplyScalar(0.13));
            fragment.rotation.x += 0.1;
            fragment.rotation.y += 0.1;
            if (fragment.position.y <= 0.01) {
              fragment.landed = true;
              fragment.visible = false;
              // Create splatter at landing spot
              const splatterSize = 0.45 + Math.random() * 0.25;
              const splatterGeometry = new THREE.BoxGeometry(splatterSize, 0.012, splatterSize);
              const splatterMaterial = new THREE.MeshBasicMaterial({
                color: baseColor,
                transparent: true,
                opacity: 0.8
              });
              const splatter = new THREE.Mesh(splatterGeometry, splatterMaterial);
              splatter.position.set(fragment.position.x, 0.015, fragment.position.z); // Raised to avoid z-fighting
              splatter.rotation.y = Math.random() * Math.PI;
              scene.add(splatter);
              splatters.push({ mesh: splatter, time: 0 });
            }
          }
        });

        // Animate explosion debris
        explosionGroup.children.forEach((particle) => {
          if (!bloodFragments.includes(particle)) {
            particle.position.add(particle.velocity.clone().multiplyScalar(0.13));
            particle.material.opacity = Math.max(1 - explosionTime * 1.2, 0);
            particle.scale.x = 1 + explosionTime * (1.5 + Math.random());
            particle.scale.y = 1 + explosionTime * (2 + Math.random());
            particle.scale.z = 1 + explosionTime * (1.5 + Math.random());
            particle.rotation.x += particle.rotationSpeed.x;
            particle.rotation.y += particle.rotationSpeed.y;
            particle.rotation.z += particle.rotationSpeed.z;
          }
        });

        // Fade splatters (stay much longer)
        splatters.forEach(obj => {
          obj.time += 0.05;
          // Stay fully visible for 2 seconds, then fade out faster
          if (obj.time < 2) {
            obj.mesh.material.opacity = 0.8;
          } else {
            obj.mesh.material.opacity = Math.max(0, 0.8 - (obj.time - 2) * 0.25);
          }
          if (obj.mesh.material.opacity === 0) {
            scene.remove(obj.mesh);
          }
        });

        if (explosionTime < 7 || splatters.some(obj => obj.mesh.material.opacity > 0)) {
          requestAnimationFrame(animateExplosion);
        } else {
          scene.remove(explosionGroup);
          splatters.forEach(obj => scene.remove(obj.mesh));
        }
      }
      animateExplosion();
    }

    // Muzzle Flash Effect
    function createMuzzleFlash(position) {
      // Muzzle flash sphere
      const flashGeometry = new THREE.SphereGeometry(0.18, 8, 8);
      const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xffff88, transparent: true, opacity: 0.8 });
      const flash = new THREE.Mesh(flashGeometry, flashMaterial);
      flash.position.copy(position);
      scene.add(flash);

      // Particle burst
      const particles = [];
      for (let i = 0; i < 8; i++) {
        const geo = new THREE.SphereGeometry(0.04, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(position);
        p.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.7,
          Math.random() * 0.5 + 0.1,
          (Math.random() - 0.5) * 0.7
        );
        scene.add(p);
        particles.push(p);
      }

      let progress = 0;
      function animateFlash() {
        progress += 0.13;
        flash.material.opacity = Math.max(0, 0.8 - progress * 1.5);
        flash.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
        particles.forEach(p => {
          p.position.add(p.velocity);
          p.material.opacity *= 0.92;
          p.scale.multiplyScalar(0.97);
        });
        if (flash.material.opacity > 0.05) {
          requestAnimationFrame(animateFlash);
        } else {
          scene.remove(flash);
          particles.forEach(p => scene.remove(p));
        }
      }
      animateFlash();
    }

    // Update Enemies
    function updateEnemies() {
      // Enemy-to-enemy separation
      for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
          const a = enemies[i];
          const b = enemies[j];
          const minDist = 0.55; // Minimum allowed distance between enemies
          const dist = a.position.distanceTo(b.position);
          if (dist < minDist && dist > 0.0001) {
            // Push them apart
            const push = a.position.clone().sub(b.position).normalize().multiplyScalar((minDist - dist) * 0.5);
            a.position.add(push);
            b.position.sub(push);
          }
        }
      }

      // Usual enemy movement toward player
      for (const enemy of enemies) {
        const direction = player.position.clone().sub(enemy.position).normalize();
        enemy.position.add(direction.multiplyScalar(0.02)); // Adjust speed as needed

        // Make the enemy face the player
        const angle = Math.atan2(player.position.x - enemy.position.x, player.position.z - enemy.position.z);
        enemy.rotation.y = angle;
      }
    }

    // Movement Controls
    const keysPressed = { w: false, a: false, s: false, d: false };
    window.addEventListener('keydown', (event) => {
      keysPressed[event.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', (event) => {
      keysPressed[event.key.toLowerCase()] = false;
    });

    function updatePlayerPosition() {
      let moved = false;
      let moveVec = new THREE.Vector3(0, 0, 0);

      if (keysPressed.w) { player.position.z -= playerSpeed; moveVec.z -= 1; moved = true; }
      if (keysPressed.s) { player.position.z += playerSpeed; moveVec.z += 1; moved = true; }
      if (keysPressed.a) { player.position.x -= playerSpeed; moveVec.x -= 1; moved = true; }
      if (keysPressed.d) { player.position.x += playerSpeed; moveVec.x += 1; moved = true; }
    }

    // Update Player Floating (Up and Down)
    function updatePlayerFloating() {
      floatTime += 0.05;
      player.position.y = 0.72 + Math.sin(floatTime) * 0.1; // Float between 0.62 and 0.82
    }

    // Update Player Rotation (Spin on Y-axis and Lean)
    function updatePlayerRotation() {
      // Calculate target lean based on movement
      targetLeanX = 0;
      targetLeanZ = 0;
      if (keysPressed.w) targetLeanX -= 0.35;
      if (keysPressed.s) targetLeanX += 0.35;
      if (keysPressed.a) targetLeanZ += 0.35;
      if (keysPressed.d) targetLeanZ -= 0.35;

      // Smoothly interpolate to target lean for natural movement
      player.rotation.x += (targetLeanX - player.rotation.x) * 0.15;
      player.rotation.z += (targetLeanZ - player.rotation.z) * 0.15;
    }

    // Wave System Variables
    let wave = 1;
    let enemiesToKill = 5; // Start with 5 enemies in wave 1
    let killedThisWave = 0;
    let waveInProgress = true;

    // Helper: Get a random integer in range [min, max]
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // HUD update function
    function animateText(el, animClass) {
      el.classList.remove(animClass);
      void el.offsetWidth;
      el.classList.add(animClass);
    }

    function updateHUD() {
      const waveHud = document.getElementById('hud');
      const killsHud = document.querySelector('#killsHud .kill-count');
      const moneyHud = document.querySelector('#moneyHud .money-count');
      const enemiesLeft = enemiesToKill - killedThisWave;

      // Only kills animates
      if (killsHud.textContent != killedThisWave) animateText(killsHud, 'kills-animate');

      waveHud.textContent = `Wave: ${wave}   |   Enemies Left: ${enemiesLeft}`;
      killsHud.textContent = killedThisWave;
      moneyHud.textContent = Math.floor(money);
    }

    // --- At the end of each wave, before showing the upgrade popup ---
    function slideOutStatsAndShowUpgrade() {
      const killsHud = document.getElementById('killsHud');
      const moneyHud = document.getElementById('moneyHud');
      killsHud.classList.add('slide-left');
      moneyHud.classList.add('slide-left');
      setTimeout(() => {
        showUpgradePopup();
        // Don't reset slide here, do it after upgrade tab closes
      }, 700);
    }

    // Game Variables
    let money = 0;
    let upgradeCosts = { range: 5, shoot: 5, money: 5 };
    let upgrades = { range: 0, shoot: 0, money: 0 };
    let playerRange = 5; // Detection radius
    let playerSpeed = 0.1; // <-- Add this line
    let shootCooldown = 3000;
    let moneyGain = 2; // Each red enemy gives 2 money
    let inUpgradeGUI = false;

    // --- Add this JS for pause functionality ---
    let hardPaused = false;

    window.addEventListener('keydown', (event) => {
      if (event.key.toLowerCase() === 'p') {
        if (!hardPaused && !inUpgradeGUI) {
          hardPaused = true;
          document.getElementById('pauseOverlay').style.display = 'flex';
          gamePaused = true;
        } else if (hardPaused) {
          hardPaused = false;
          document.getElementById('pauseOverlay').style.display = 'none';
          gamePaused = false;
        }
      }
    });

    // Pause game if the user leaves the page or switches tabs
    window.addEventListener('blur', () => {
      if (!hardPaused) {
        hardPaused = true;
        document.getElementById('pauseOverlay').style.display = 'flex';
        gamePaused = true;
      }
    });

    // Optionally, resume only on 'P' key, not on focus
    // If you want to auto-resume on focus, add this:
    // window.addEventListener('focus', () => {
    //   if (hardPaused) {
    //     hardPaused = false;
    //     document.getElementById('pauseOverlay').style.display = 'none';
    //     gamePaused = false;
    //   }
    // });

    // Upgrade Popup Logic
    function showUpgradePopup() {
      inUpgradeGUI = true;
      gamePaused = true;
      const overlay = document.getElementById('upgradeOverlay');
      const panel = document.getElementById('upgradePanel');
      const tabs = document.getElementById('upgradeTabs');
      const msg = document.getElementById('upgradeMsg');
      overlay.style.display = 'block';
      setTimeout(() => {
        overlay.style.background = 'rgba(0,0,0,0.85)';
        panel.style.opacity = 1;
        animateText(panel.querySelector('h2'), 'upgrade-title-animate');
      }, 10);

      // --- Add summary above upgrades ---
      let summary = document.getElementById('upgradeSummary');
      if (!summary) {
        summary = document.createElement('div');
        summary.id = 'upgradeSummary';
        panel.insertBefore(summary, panel.querySelector('h2').nextSibling);
      }
      summary.textContent = `Kills: ${killedThisWave}   Money: $${Math.floor(money)}`;

      // --- Add timer/line at the top ---
      let timerBar = document.getElementById('upgradeTimerBar');
      let timerText = document.getElementById('upgradeTimerText');
      if (!timerBar) {
        timerBar = document.createElement('div');
        timerBar.id = 'upgradeTimerBar';
        panel.insertBefore(timerBar, summary);
        timerText = document.createElement('div');
        timerText.id = 'upgradeTimerText';
        timerBar.appendChild(timerText);
      }
      timerBar.style.height = "4px";
      timerText.textContent = "8.0s";
      timerBar.innerHTML = `<div id="upgradeTimerFill"></div>`;
      timerBar.appendChild(timerText);

      // Timer logic (unchanged)
      let timer = 8.0;
      let timerInterval = setInterval(() => {
        timer -= 0.1;
        if (timer < 0) timer = 0;
        timerText.textContent = timer.toFixed(1) + "s";
        document.getElementById('upgradeTimerFill').style.width = (timer / 8 * 100) + "%";
        if (timer <= 0) {
          clearInterval(timerInterval);
          hideUpgradePopup();
        }
      }, 100);

      // Build upgrade buttons
      tabs.innerHTML = '';
      msg.textContent = '';
      const upgradesList = [
        { key: 'range', label: `Range +1%`, desc: `(${upgradeCosts.range} kills)` },
        { key: 'shoot', label: `Shoot Rate +1%`, desc: `(${upgradeCosts.shoot} kills)` },
        { key: 'money', label: `Money x1.5`, desc: `(${upgradeCosts.money} kills)` }
      ];
      upgradesList.forEach((upg, idx) => {
        const btn = document.createElement('button');
        btn.textContent = `${upg.label}\n${upg.desc}`;
        btn.style.cssText = `
          background:#222; color:#00ff88; border:2px solid #00ff88; border-radius:8px; padding:18px 22px; font-size:1.1em; font-family:monospace;
          cursor:pointer; transition:background 0.2s, color 0.2s, box-shadow 0.3s; white-space:pre; min-width:120px;
          margin-bottom: 0;
        `;
        btn.onmouseenter = () => { btn.style.background = '#00ff88'; btn.style.color = '#222'; btn.style.boxShadow = '0 0 16px #00ff88'; };
        btn.onmouseleave = () => { btn.style.background = '#222'; btn.style.color = '#00ff88'; btn.style.boxShadow = 'none'; };
        btn.onclick = () => {
          clearInterval(timerInterval);
          if (killedThisWave < upgradeCosts[upg.key]) {
            msg.textContent = "Not enough kills!";
            animateText(msg, 'upgrade-msg-animate');
            return;
          }
          killedThisWave -= upgradeCosts[upg.key];
          upgrades[upg.key]++;
          upgradeCosts[upg.key] += 5;
          if (upg.key === 'range') playerRange *= 1.01;
          if (upg.key === 'shoot') shootCooldown = Math.floor(shootCooldown * 0.99);
          if (upg.key === 'money') moneyGain = Math.floor(moneyGain * 1.5);
          msg.textContent = `Upgraded: ${upg.label.split(' ')[0]}!`;
          animateText(msg, 'upgrade-msg-animate');
          updateHUD();
          setTimeout(hideUpgradePopup, 700);
        };
        tabs.appendChild(btn);
        setTimeout(() => animateText(btn, 'upgrade-btn-animate'), 120 * idx);
      });

      const continueBtn = document.createElement('button');
      continueBtn.textContent = "Continue";
      continueBtn.style.cssText = `
        background:#222; color:#00ff88; border:2px solid #00ff88; border-radius:8px; padding:12px 32px; font-size:1.1em; font-family:monospace;
        margin-top:18px; cursor:pointer; transition:background 0.2s, color 0.2s, box-shadow 0.3s;
      `;
      continueBtn.onmouseenter = () => { continueBtn.style.background = '#00ff88'; continueBtn.style.color = '#222'; continueBtn.style.boxShadow = '0 0 16px #00ff88'; };
      continueBtn.onmouseleave = () => { continueBtn.style.background = '#222'; continueBtn.style.color = '#00ff88'; continueBtn.style.boxShadow = 'none'; };
      continueBtn.onclick = () => { clearInterval(timerInterval); hideUpgradePopup(); };
      tabs.appendChild(continueBtn);
      setTimeout(() => animateText(continueBtn, 'upgrade-btn-animate'), 400);
    }

    function hideUpgradePopup() {
      inUpgradeGUI = false;
      const killsHud = document.getElementById('killsHud');
      const moneyHud = document.getElementById('moneyHud');
      const overlay = document.getElementById('upgradeOverlay');
      const panel = document.getElementById('upgradePanel');
      overlay.style.background = 'rgba(0,0,0,0)';
      panel.style.opacity = 0;
      setTimeout(() => { overlay.style.display = 'none'; }, 500);
      // Slide stats back in
      killsHud.style.opacity = 0;
      moneyHud.style.opacity = 0;
      killsHud.classList.remove('slide-left');
      moneyHud.classList.remove('slide-left');
      setTimeout(() => {
        killsHud.style.transition = 'opacity 0.5s';
        moneyHud.style.transition = 'opacity 0.5s';
        killsHud.style.opacity = 1;
        moneyHud.style.opacity = 1;
        setTimeout(() => {
          killsHud.style.transition = '';
          moneyHud.style.transition = '';
        }, 500);
      }, 10);
      // Start next wave
      setTimeout(() => {
        wave++;
        enemiesToKill = 5 + randomInt(0, 7) + wave * 2;
        killedThisWave = 0;
        waveInProgress = true;
        updateHUD();
        gamePaused = false;
      }, 500);
    }

    // --- Remove all but one window.onload, and use this: ---
    window.onload = function() {
      animate(); // Start the render loop, but game logic only runs when not paused
      gamePaused = false;
    };

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);

      if (!gamePaused) {
        updatePlayerPosition();
        updateProjectiles();
        updateEnemies();
        updateDetectionSphere();
        updateCrystalLight();
        autoShootAtEnemies();
        updatePlayerRotation();
        updatePlayerFloating();
      }
      updateHUD();
      renderer.render(scene, camera);
    }

    // Camera
    camera.position.set(0, 9, 16);
    camera.lookAt(0, 0, 0);
  </script>
  <div id="pauseOverlay">
    <div class="pause-content">
      <div>PAUSED</div>
      <div style="font-size:0.6em; margin-top:18px;">Press <b>P</b> to resume</div>
    </div>
  </div>
</body>
</html>
